var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { DELETE, DELETE_MANY } from 'ra-core';
import { CRUD_GET_TREE_ROOT_NODES_SUCCESS, CRUD_GET_TREE_CHILDREN_NODES_SUCCESS, MOVE_NODE, } from '../actions';
import { ROOT_NODE_ID } from '../constants';
/**
 * This reducer maintains a map of all nodes (using their id) and their children (only their id too).
 * Root nodes are persisted as the children of a special node which has the identifier ROOT_NODE_ID
 * @example
 * {
 *     ROOT_NODE_ID: [1, 2],
 *     1: [3, 4],
 *     2: [5, 6],
 * }
 */
var nodesReducer = function (previousState, action) {
    if (previousState === void 0) { previousState = (_a = {}, _a[ROOT_NODE_ID] = [], _a); }
    var _a, _b, _c;
    if (action.meta && action.meta.optimistic) {
        if (action.meta.fetch === MOVE_NODE) {
            return moveNode(previousState, action);
        }
        if (action.meta.fetch === DELETE) {
            return removeNodes(previousState, [action.payload.id]);
        }
        if (action.meta.fetch === DELETE_MANY) {
            return removeNodes(previousState, action.payload.ids);
        }
    }
    switch (action.type) {
        case CRUD_GET_TREE_ROOT_NODES_SUCCESS: {
            var newState = __assign({}, previousState, (_b = {}, _b[ROOT_NODE_ID] = action.payload.data.map(function (_a) {
                var id = _a.id;
                return id;
            }), _b), setupNodesChildren(previousState, action.payload.data));
            return newState;
        }
        case CRUD_GET_TREE_CHILDREN_NODES_SUCCESS: {
            var newState = __assign({}, previousState, (_c = {}, _c[action.requestPayload.id] = 
            // The children value for this node may be false to indicate we fetched them but found none
            action.payload.data.length > 0
                ? action.payload.data.map(function (_a) {
                    var id = _a.id;
                    return id;
                })
                : false, _c), setupNodesChildren(previousState, action.payload.data));
            return newState;
        }
        default:
            return previousState;
    }
};
export default nodesReducer;
var setupNodesChildren = function (previousState, nodes) {
    return nodes.reduce(function (acc, _a) {
        var id = _a.id;
        var _b;
        return (__assign({}, acc, (_b = {}, _b[id] = previousState[id] != undefined // eslint-disable-line eqeqeq
            ? previousState[id]
            : [], _b)));
    }, {});
};
var moveNode = function (previousState, action) {
    var _a;
    // We need to remove this node from its previous parent as it may have changed
    var previousParentId = action.payload.previousData[action.meta.parentSource] || ROOT_NODE_ID;
    var updatedPreviousParent = previousState[previousParentId].filter(function (id) { return id !== action.payload.data.id; });
    var newState = __assign({}, previousState, (_a = {}, _a[previousParentId] = updatedPreviousParent, _a));
    // Then we need to update the new parent (which may be the same)
    var newParentId = action.payload.data[action.meta.parentSource] || ROOT_NODE_ID;
    // The new parent may not have any child yet
    var currentParentChildren = newState[newParentId] || [];
    // We may have to update the node position
    if (action.meta.positionSource) {
        var childrenBeforeMovedNode = currentParentChildren.slice(0, action.payload.data[action.meta.positionSource]);
        var childrenAfterMovedNode = currentParentChildren.slice(action.payload.data[action.meta.positionSource]);
        newState[newParentId] = childrenBeforeMovedNode.concat([
            action.payload.data.id
        ], childrenAfterMovedNode);
        return newState;
    }
    // Otherwise, we just append the moved node to its new parent
    newState[newParentId] = currentParentChildren.concat([action.payload.data.id]);
    return newState;
};
var removeNodes = function (previousState, idsToRemove) {
    return idsToRemove.reduce(function (newState, idToRemove) {
        // Traverse all registered nodes and remove the node from their children
        return Object.keys(newState).reduce(function (acc, id) {
            var _a, _b;
            // If this is a removed node or this node has no children (false indicates we fetched them but found none)
            if (id === idToRemove || newState[id] === false) {
                return acc;
            }
            var children = newState[id];
            var index = children.findIndex(function (nodeId) { return nodeId === idToRemove; });
            if (index === -1) {
                return __assign({}, acc, (_a = {}, _a[id] = children, _a));
            }
            return __assign({}, acc, (_b = {}, _b[id] = children.slice(0, index).concat(children.slice(index + 1)), _b));
        }, {});
    }, previousState);
};
