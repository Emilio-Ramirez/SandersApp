var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import React, { Component, Children, cloneElement, isValidElement, } from 'react';
import { findDOMNode } from 'react-dom';
import { connect } from 'react-redux';
import compose from 'recompose/compose';
import classnames from 'classnames';
import ListItem from '@material-ui/core/ListItem';
import { withStyles, } from '@material-ui/core/styles';
import isEqual from 'lodash/isEqual';
import { crudGetTreeChildrenNodes as crudGetTreeChildrenNodesAction, crudMoveNode as crudMoveNodeAction, getIsExpanded, getIsLoading, getChildrenNodes, toggleNode as toggleNodeAction, } from 'ra-tree-core';
import { withTranslate, startUndoable as startUndoableAction, } from 'ra-core';
import { DragSource, DropTarget, } from 'react-dnd';
import TreeNodeList from './TreeNodeList';
import TreeNodeIcon from './TreeNodeIcon';
import getMousePosition from './getMousePosition';
var TreeNodeView = /** @class */ (function (_super) {
    __extends(TreeNodeView, _super);
    function TreeNodeView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handleClick = function () {
            _this.props.toggleNode({
                resource: _this.props.resource,
                nodeId: _this.props.record.id,
            });
            // If the node wasn't expanded, the previous line is actually requesting
            // it to expand, so we reload its children to be sure they are up to date
            if (!_this.props.expanded) {
                _this.fetchChildren();
            }
        };
        _this.fetchChildren = function () {
            var _a = _this.props, crudGetTreeChildrenNodes = _a.crudGetTreeChildrenNodes, parentSource = _a.parentSource, positionSource = _a.positionSource, record = _a.record, resource = _a.resource;
            // eslint-disable-next-line eqeqeq
            if (record && record.id != undefined) {
                crudGetTreeChildrenNodes({
                    resource: resource,
                    parentSource: parentSource,
                    positionSource: positionSource,
                    nodeId: record.id,
                });
            }
        };
        return _this;
    }
    TreeNodeView.prototype.componentDidMount = function () {
        this.fetchChildren();
    };
    TreeNodeView.prototype.componentDidUpdate = function (prevProps) {
        // Automatically expand the node when dragging another node over it
        if (!this.props.expanded &&
            (this.props.isOverCurrent ||
                (this.props.isOver && !!this.props.positionSource)) &&
            !this.props.isDragging) {
            this.handleClick();
        }
        if (!isEqual(this.props.record, prevProps.record)) {
            this.fetchChildren();
        }
    };
    TreeNodeView.prototype.render = function () {
        var _a;
        var _b = this.props, actions = _b.actions, basePath = _b.basePath, canDrag = _b.canDrag, canDrop = _b.canDrop, children = _b.children, className = _b.className, classes = _b.classes, connectDragSource = _b.connectDragSource, connectDropTarget = _b.connectDropTarget, crudGetTreeChildrenNodes = _b.crudGetTreeChildrenNodes, crudMoveNode = _b.crudMoveNode, expanded = _b.expanded, hasCreate = _b.hasCreate, hasEdit = _b.hasEdit, hasList = _b.hasList, hasShow = _b.hasShow, isDragging = _b.isDragging, isOver = _b.isOver, isOverCurrent = _b.isOverCurrent, loading = _b.loading, nodeChildren = _b.nodeChildren, nodes = _b.nodes, parentSource = _b.parentSource, positionSource = _b.positionSource, record = _b.record, resource = _b.resource, startUndoable = _b.startUndoable, toggleNode = _b.toggleNode, translate = _b.translate, undoable = _b.undoable, props = __rest(_b, ["actions", "basePath", "canDrag", "canDrop", "children", "className", "classes", "connectDragSource", "connectDropTarget", "crudGetTreeChildrenNodes", "crudMoveNode", "expanded", "hasCreate", "hasEdit", "hasList", "hasShow", "isDragging", "isOver", "isOverCurrent", "loading", "nodeChildren", "nodes", "parentSource", "positionSource", "record", "resource", "startUndoable", "toggleNode", "translate", "undoable"]);
        if (!record) {
            return null;
        }
        // The children value for this node may be false (indicating we fetched them but found none)
        // We don't want to show the loading indicator all the time, only on the first fetch
        var showLoading = loading && (Array.isArray(nodes) && nodes.length === 0);
        return connectDropTarget(connectDragSource(React.createElement("li", __assign({ className: classnames((_a = {},
                _a[classes.draggedOver] = canDrop &&
                    (isOverCurrent || (isOver && !!positionSource)),
                // This is a hack to cancel styles added dynamically on hover by our react-dnd target,
                // which are not correctly removed once the dragged item leaves this node
                _a[classes.resetDraggedOver] = !isOverCurrent,
                _a)), "data-position": record[positionSource] }, props),
            React.createElement(ListItem, { className: classnames(classes.root, className), divider: !expanded, component: "div" },
                React.createElement("div", { className: classes.container },
                    React.createElement(TreeNodeIcon, { expanded: expanded, loading: showLoading, hasChildren: nodes && nodes.length > 0, onClick: this.handleClick }),
                    React.createElement("div", { className: classes.content },
                        Children.map(children, function (child) {
                            return isValidElement(child)
                                ? cloneElement(child, {
                                    basePath: basePath,
                                    record: record,
                                })
                                : null;
                        }),
                        actions && isValidElement(actions)
                            ? cloneElement(actions, __assign({ basePath: basePath,
                                parentSource: parentSource,
                                positionSource: positionSource,
                                record: record,
                                resource: resource }, actions.props))
                            : null)),
                expanded ? (React.createElement(TreeNodeList, { basePath: basePath, hasCreate: hasCreate, hasEdit: hasEdit, hasList: hasList, hasShow: hasShow, nodes: nodes, parentSource: parentSource, positionSource: positionSource, resource: resource }, nodeChildren)) : null))));
    };
    return TreeNodeView;
}(Component));
var styles = function (theme) { return ({
    root: {
        display: 'inline-block',
        verticalAlign: 'middle',
        paddingRight: 0,
    },
    draggedOver: {
        backgroundColor: theme.palette.action.hover,
    },
    resetDraggedOver: {
        '&.draggedAbove': {
            borderTopStyle: 'none',
        },
        '&.draggedBelow': {
            borderBottomStyle: 'none',
        },
    },
    draggedAbove: {
        borderTopWidth: 2,
        borderTopStyle: 'solid',
        borderTopColor: theme.palette.action.active,
    },
    draggedBelow: {
        borderBottomWidth: 2,
        borderBottomStyle: 'solid',
        borderBottomColor: theme.palette.action.active,
    },
    container: {
        alignItems: 'center',
        display: 'flex',
        verticalAlign: 'middle',
    },
    content: {
        alignItems: 'center',
        display: 'flex',
        flex: 1,
    },
}); };
var mapStateToProps = function (state, _a) {
    var record = _a.record, resource = _a.resource;
    var hasRecord = record && record.id != undefined; // eslint-disable-line eqeqeq
    return {
        expanded: hasRecord ? getIsExpanded(state, resource, record.id) : false,
        loading: hasRecord ? getIsLoading(state, resource, record.id) : false,
        nodes: hasRecord ? getChildrenNodes(state, resource, record.id) : [],
    };
};
// This object contains the react-dnd drop target specification
// See https://react-dnd.github.io/react-dnd/docs/api/drop-target
var nodeTarget = {
    canDrop: function (props, monitor) {
        var draggedRecord = monitor.getItem().record;
        var isJustOverThisOne = monitor.isOver({ shallow: true });
        var canDrop = props.canDrop
            ? props.canDrop({
                dropTarget: props.record,
                dragSource: draggedRecord,
            })
            : true;
        var isNotDroppingOverItself = props.record.id !== draggedRecord.id;
        return isJustOverThisOne && canDrop && isNotDroppingOverItself;
    },
    // This function is call when a node is dragged over another one
    // It is called for every mouse moves and we use it when nodes are ordered
    // to show lines above or under depending on the mouse position
    hover: function (props, monitor, component) {
        // If nodes are not ordered we have nothing to do
        if (!props.positionSource) {
            return;
        }
        var domNode = findDOMNode(component);
        var item = monitor.getItem();
        var canDrop = monitor.canDrop();
        var isOverCurrent = monitor.isOver({ shallow: true });
        var droppedPosition = 'none';
        // If the draggged node is over a child of this node, we have nothing to do
        if (!isOverCurrent) {
            return;
        }
        if (item && canDrop) {
            // Determine rectangle on screen
            var hoverBoundingRect = domNode.getBoundingClientRect();
            // Determine mouse position
            var mousePosition = monitor.getClientOffset();
            droppedPosition = getMousePosition(hoverBoundingRect, mousePosition);
        }
        switch (droppedPosition) {
            case 'above': {
                domNode.classList.remove(props.classes.draggedBelow);
                domNode.classList.add(props.classes.draggedAbove);
                break;
            }
            case 'below': {
                domNode.classList.remove(props.classes.draggedAbove);
                domNode.classList.add(props.classes.draggedBelow);
                break;
            }
            default:
                domNode.classList.remove(props.classes.draggedAbove);
                domNode.classList.remove(props.classes.draggedBelow);
                break;
        }
    },
    // This function is called when a node is dropped over the current one
    drop: function (props, monitor, component) {
        var _a;
        if (monitor.didDrop()) {
            return;
        }
        var draggedRecord = monitor.getItem().record;
        var domNode = findDOMNode(component);
        // Determine rectangle on screen
        var hoverBoundingRect = domNode.getBoundingClientRect();
        // Determine mouse position
        var mousePosition = monitor.getClientOffset();
        var droppedPosition = getMousePosition(hoverBoundingRect, mousePosition);
        // If the item was dropped over the component, its record will be the new parent of the item,
        // otherwise the parent will be the record's parent
        var nodeParent = droppedPosition === 'over'
            ? props.record.id
            : props.record[props.parentSource];
        var nodePosition = !props.positionSource
            ? undefined
            : droppedPosition === 'above'
                ? props.record[props.positionSource]
                : droppedPosition === 'below'
                    ? props.record[props.positionSource]
                    : props.nodes.length - 1;
        var actionPayload = {
            resource: props.resource,
            data: __assign({}, draggedRecord, (_a = {}, _a[props.parentSource] = nodeParent, _a[props.positionSource] = nodePosition, _a)),
            parentSource: props.parentSource,
            positionSource: props.positionSource,
            previousData: draggedRecord,
            basePath: props.basePath,
            refresh: false,
            redirectTo: undefined,
        };
        if (props.undoable) {
            props.startUndoable(crudMoveNodeAction(actionPayload));
        }
        else {
            props.crudMoveNode(actionPayload);
        }
    },
};
var collectDropTarget = function (connect, monitor) { return ({
    connectDropTarget: connect.dropTarget(),
    isOver: monitor.isOver(),
    isOverCurrent: monitor.isOver({ shallow: true }),
    canDrop: monitor.canDrop(),
}); };
// This object contains the react-dnd drag source specification
// See https://react-dnd.github.io/react-dnd/docs/api/drag-source
var nodeSource = {
    canDrag: function (props) {
        return props.canDrag ? props.canDrag(props.record) : true;
    },
    isDragging: function (props, monitor) {
        return monitor.getItem().record.id === props.record.id;
    },
    beginDrag: function (props, monitor, component) {
        // Returns the node record as the item being dragged
        // It will be returned for every call to monitor.getItem()
        return { record: props.record, component: component };
    },
};
var collectDragSource = function (connect, monitor) { return ({
    connectDragSource: connect.dragSource(),
    isDragging: monitor.isDragging(),
}); };
var TreeNode = compose(connect(mapStateToProps, {
    crudGetTreeChildrenNodes: crudGetTreeChildrenNodesAction,
    crudMoveNode: crudMoveNodeAction,
    startUndoable: startUndoableAction,
    toggleNode: toggleNodeAction,
}), withStyles(styles), DropTarget('TREE_NODE', nodeTarget, collectDropTarget), DragSource('TREE_NODE', nodeSource, collectDragSource), withTranslate)(TreeNodeView);
TreeNode.defaultProps = {
    undoable: true,
};
export default TreeNode;
